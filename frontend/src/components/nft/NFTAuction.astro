---
// NFTAuction.astro - Advanced NFT auction component
export interface Props {
  nftId: string;
  nftName: string;
  nftImage: string;
  collectionName?: string;
  currentBid?: number;
  minBid?: number;
  timeRemaining?: number;
  highestBidder?: string;
  auctionStatus?: 'upcoming' | 'active' | 'ended' | 'cancelled';
  onBid?: (amount: number) => void;
  onEndAuction?: () => void;
  onCancelAuction?: () => void;
}

const {
  nftId,
  nftName,
  nftImage,
  collectionName = '',
  currentBid = 0,
  minBid = 0.1,
  timeRemaining = 0,
  highestBidder = '',
  auctionStatus = 'active',
  onBid,
  onEndAuction,
  onCancelAuction
} = Astro.props;

// Calculate time remaining
const formatTimeRemaining = (seconds: number) => {
  const days = Math.floor(seconds / 86400);
  const hours = Math.floor((seconds % 86400) / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;
  
  if (days > 0) return `${days}d ${hours}h ${minutes}m`;
  if (hours > 0) return `${hours}h ${minutes}m ${secs}s`;
  if (minutes > 0) return `${minutes}m ${secs}s`;
  return `${secs}s`;
};

const getStatusColor = (status: string) => {
  switch (status) {
    case 'upcoming': return 'text-blue-600 bg-blue-100';
    case 'active': return 'text-green-600 bg-green-100';
    case 'ended': return 'text-gray-600 bg-gray-100';
    case 'cancelled': return 'text-red-600 bg-red-100';
    default: return 'text-gray-600 bg-gray-100';
  }
};
---

<div class="nft-auction" data-nft-id={nftId}>
  <div class="auction-header">
    <div class="nft-info">
      <img src={nftImage} alt={nftName} class="nft-image" />
      <div class="nft-details">
        <h3 class="nft-name">{nftName}</h3>
        {collectionName && (
          <p class="collection-name">{collectionName}</p>
        )}
      </div>
    </div>
    <div class={`auction-status ${getStatusColor(auctionStatus)}`}>
      {auctionStatus.toUpperCase()}
    </div>
  </div>

  <div class="auction-content">
    <div class="bid-info">
      <div class="current-bid">
        <span class="bid-label">Current Bid</span>
        <span class="bid-amount">{currentBid.toFixed(3)} SOL</span>
      </div>
      <div class="min-bid">
        <span class="min-bid-label">Min. Bid</span>
        <span class="min-bid-amount">{minBid.toFixed(3)} SOL</span>
      </div>
    </div>

    {auctionStatus === 'active' && (
      <div class="time-remaining">
        <span class="time-label">Time Remaining</span>
        <span class="time-value" id="time-remaining">
          {formatTimeRemaining(timeRemaining)}
        </span>
      </div>
    )}

    {highestBidder && (
      <div class="highest-bidder">
        <span class="bidder-label">Highest Bidder</span>
        <span class="bidder-address">
          {highestBidder.slice(0, 8)}...{highestBidder.slice(-4)}
        </span>
      </div>
    )}

    {auctionStatus === 'active' && (
      <div class="bid-section">
        <div class="bid-form">
          <label for="bid-amount" class="bid-form-label">Your Bid (SOL)</label>
          <div class="bid-input-group">
            <input 
              type="number" 
              id="bid-amount" 
              class="bid-input" 
              min={minBid}
              step="0.001"
              placeholder={`Min: ${minBid}`}
            />
            <button class="bid-button" id="place-bid-btn">
              Place Bid
            </button>
          </div>
          <div class="bid-suggestions">
            <button class="suggestion-btn" data-amount={minBid}>
              {minBid} SOL
            </button>
            <button class="suggestion-btn" data-amount={minBid * 1.1}>
              {(minBid * 1.1).toFixed(3)} SOL
            </button>
            <button class="suggestion-btn" data-amount={minBid * 1.5}>
              {(minBid * 1.5).toFixed(3)} SOL
            </button>
          </div>
        </div>
      </div>
    )}

    {auctionStatus === 'upcoming' && (
      <div class="upcoming-info">
        <p class="upcoming-text">Auction starts soon</p>
        <div class="countdown" id="countdown">
          {formatTimeRemaining(timeRemaining)}
        </div>
      </div>
    )}

    {auctionStatus === 'ended' && (
      <div class="ended-info">
        <p class="ended-text">Auction has ended</p>
        {highestBidder && (
          <p class="winner-text">
            Winner: {highestBidder.slice(0, 8)}...{highestBidder.slice(-4)}
          </p>
        )}
      </div>
    )}

    {auctionStatus === 'cancelled' && (
      <div class="cancelled-info">
        <p class="cancelled-text">Auction was cancelled</p>
      </div>
    )}

    <div class="auction-actions">
      {auctionStatus === 'active' && (
        <button class="action-btn end-auction-btn" id="end-auction-btn">
          End Auction
        </button>
      )}
      {auctionStatus === 'upcoming' && (
        <button class="action-btn cancel-auction-btn" id="cancel-auction-btn">
          Cancel Auction
        </button>
      )}
      <button class="action-btn view-details-btn" id="view-details-btn">
        View Details
      </button>
    </div>
  </div>

  <div class="auction-history" id="auction-history">
    <h4 class="history-title">Bid History</h4>
    <div class="history-list" id="history-list">
      <div class="history-item">
        <span class="bidder">Loading...</span>
        <span class="bid-amount">-</span>
        <span class="bid-time">-</span>
      </div>
    </div>
  </div>
</div>

<script>
  import { enhancedSolanaWalletService } from '../../services/solana/solana-wallet';

  class NFTAuction {
    private nftId: string;
    private currentBid: number;
    private minBid: number;
    private timeRemaining: number;
    private auctionStatus: string;
    private bidHistory: Array<{bidder: string, amount: number, timestamp: number}> = [];
    private countdownInterval: number | null = null;

    constructor(nftId: string, currentBid: number, minBid: number, timeRemaining: number, auctionStatus: string) {
      this.nftId = nftId;
      this.currentBid = currentBid;
      this.minBid = minBid;
      this.timeRemaining = timeRemaining;
      this.auctionStatus = auctionStatus;
      
      this.initializeElements();
      this.setupEventListeners();
      this.startCountdown();
      this.loadBidHistory();
    }

    private initializeElements() {
      // This will be called when the component is mounted
    }

    private setupEventListeners() {
      document.addEventListener('DOMContentLoaded', () => {
        // Place bid button
        const placeBidBtn = document.getElementById('place-bid-btn');
        placeBidBtn?.addEventListener('click', () => this.placeBid());

        // Bid amount input
        const bidAmountInput = document.getElementById('bid-amount') as HTMLInputElement;
        bidAmountInput?.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            this.placeBid();
          }
        });

        // Suggestion buttons
        const suggestionBtns = document.querySelectorAll('.suggestion-btn');
        suggestionBtns.forEach(btn => {
          btn.addEventListener('click', (e) => {
            const amount = parseFloat((e.target as HTMLElement).getAttribute('data-amount') || '0');
            if (bidAmountInput) {
              bidAmountInput.value = amount.toString();
            }
          });
        });

        // End auction button
        const endAuctionBtn = document.getElementById('end-auction-btn');
        endAuctionBtn?.addEventListener('click', () => this.endAuction());

        // Cancel auction button
        const cancelAuctionBtn = document.getElementById('cancel-auction-btn');
        cancelAuctionBtn?.addEventListener('click', () => this.cancelAuction());

        // View details button
        const viewDetailsBtn = document.getElementById('view-details-btn');
        viewDetailsBtn?.addEventListener('click', () => this.viewDetails());
      });
    }

    private startCountdown() {
      if (this.auctionStatus !== 'active' && this.auctionStatus !== 'upcoming') {
        return;
      }

      this.countdownInterval = setInterval(() => {
        if (this.timeRemaining <= 0) {
          this.endAuction();
          if (this.countdownInterval) {
            clearInterval(this.countdownInterval);
          }
          return;
        }

        this.timeRemaining--;
        this.updateCountdownDisplay();
      }, 1000);
    }

    private updateCountdownDisplay() {
      const timeElement = document.getElementById('time-remaining');
      const countdownElement = document.getElementById('countdown');
      
      const timeString = this.formatTimeRemaining(this.timeRemaining);
      
      if (timeElement) {
        timeElement.textContent = timeString;
      }
      if (countdownElement) {
        countdownElement.textContent = timeString;
      }

      // Add warning when time is running low
      if (this.timeRemaining < 300) { // 5 minutes
        if (timeElement) {
          timeElement.classList.add('text-red-600', 'font-bold');
        }
        if (countdownElement) {
          countdownElement.classList.add('text-red-600', 'font-bold');
        }
      }
    }

    private formatTimeRemaining(seconds: number): string {
      const days = Math.floor(seconds / 86400);
      const hours = Math.floor((seconds % 86400) / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = seconds % 60;
      
      if (days > 0) return `${days}d ${hours}h ${minutes}m`;
      if (hours > 0) return `${hours}h ${minutes}m ${secs}s`;
      if (minutes > 0) return `${minutes}m ${secs}s`;
      return `${secs}s`;
    }

    private async placeBid() {
      const bidAmountInput = document.getElementById('bid-amount') as HTMLInputElement;
      const bidAmount = parseFloat(bidAmountInput?.value || '0');

      if (!bidAmount || bidAmount < this.minBid) {
        this.showNotification(`Bid must be at least ${this.minBid} SOL`, 'error');
        return;
      }

      if (!enhancedSolanaWalletService.isConnected()) {
        this.showNotification('Please connect your wallet first', 'error');
        return;
      }

      try {
        this.showNotification('Placing bid...', 'info');
        
        // In a real implementation, this would call the smart contract
        const result = await this.submitBid(bidAmount);
        
        if (result.success) {
          this.currentBid = bidAmount;
          this.updateBidDisplay();
          this.addBidToHistory(enhancedSolanaWalletService.getWalletInfo()?.publicKey || '', bidAmount);
          this.showNotification('Bid placed successfully!', 'success');
          bidAmountInput.value = '';
        } else {
          this.showNotification(result.error || 'Failed to place bid', 'error');
        }
      } catch (error) {
        this.showNotification('Error placing bid', 'error');
        console.error('Bid error:', error);
      }
    }

    private async submitBid(amount: number): Promise<{success: boolean, error?: string}> {
      // Mock implementation - in a real app, this would call the smart contract
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Simulate random success/failure
      return Math.random() > 0.1 ? { success: true } : { success: false, error: 'Transaction failed' };
    }

    private updateBidDisplay() {
      const bidAmountElement = document.querySelector('.bid-amount');
      if (bidAmountElement) {
        bidAmountElement.textContent = `${this.currentBid.toFixed(3)} SOL`;
      }
    }

    private addBidToHistory(bidder: string, amount: number) {
      const bid = {
        bidder,
        amount,
        timestamp: Date.now()
      };
      
      this.bidHistory.unshift(bid);
      this.updateBidHistory();
    }

    private updateBidHistory() {
      const historyList = document.getElementById('history-list');
      if (!historyList) return;

      if (this.bidHistory.length === 0) {
        historyList.innerHTML = '<div class="history-item">No bids yet</div>';
        return;
      }

      historyList.innerHTML = this.bidHistory.map(bid => `
        <div class="history-item">
          <span class="bidder">${bid.bidder.slice(0, 8)}...${bid.bidder.slice(-4)}</span>
          <span class="bid-amount">${bid.amount.toFixed(3)} SOL</span>
          <span class="bid-time">${new Date(bid.timestamp).toLocaleTimeString()}</span>
        </div>
      `).join('');
    }

    private async loadBidHistory() {
      try {
        // In a real implementation, this would fetch from the API
        const mockHistory = [
          { bidder: 'Bidder1Address123', amount: 1.5, timestamp: Date.now() - 3600000 },
          { bidder: 'Bidder2Address456', amount: 2.0, timestamp: Date.now() - 1800000 },
          { bidder: 'Bidder3Address789', amount: 2.5, timestamp: Date.now() - 900000 }
        ];
        
        this.bidHistory = mockHistory;
        this.updateBidHistory();
      } catch (error) {
        console.error('Failed to load bid history:', error);
      }
    }

    private async endAuction() {
      if (!enhancedSolanaWalletService.isConnected()) {
        this.showNotification('Please connect your wallet first', 'error');
        return;
      }

      try {
        this.showNotification('Ending auction...', 'info');
        
        // In a real implementation, this would call the smart contract
        const result = await this.submitEndAuction();
        
        if (result.success) {
          this.auctionStatus = 'ended';
          this.updateAuctionStatus();
          this.showNotification('Auction ended successfully!', 'success');
        } else {
          this.showNotification(result.error || 'Failed to end auction', 'error');
        }
      } catch (error) {
        this.showNotification('Error ending auction', 'error');
        console.error('End auction error:', error);
      }
    }

    private async submitEndAuction(): Promise<{success: boolean, error?: string}> {
      // Mock implementation
      await new Promise(resolve => setTimeout(resolve, 2000));
      return { success: true };
    }

    private async cancelAuction() {
      if (!enhancedSolanaWalletService.isConnected()) {
        this.showNotification('Please connect your wallet first', 'error');
        return;
      }

      try {
        this.showNotification('Cancelling auction...', 'info');
        
        // In a real implementation, this would call the smart contract
        const result = await this.submitCancelAuction();
        
        if (result.success) {
          this.auctionStatus = 'cancelled';
          this.updateAuctionStatus();
          this.showNotification('Auction cancelled successfully!', 'success');
        } else {
          this.showNotification(result.error || 'Failed to cancel auction', 'error');
        }
      } catch (error) {
        this.showNotification('Error cancelling auction', 'error');
        console.error('Cancel auction error:', error);
      }
    }

    private async submitCancelAuction(): Promise<{success: boolean, error?: string}> {
      // Mock implementation
      await new Promise(resolve => setTimeout(resolve, 2000));
      return { success: true };
    }

    private viewDetails() {
      this.showNotification('Opening NFT details...', 'info');
      // In a real implementation, this would navigate to NFT details page
    }

    private updateAuctionStatus() {
      const statusElement = document.querySelector('.auction-status');
      if (statusElement) {
        statusElement.textContent = this.auctionStatus.toUpperCase();
        statusElement.className = `auction-status ${this.getStatusColor(this.auctionStatus)}`;
      }

      // Hide/show relevant sections based on status
      const bidSection = document.querySelector('.bid-section');
      const upcomingInfo = document.querySelector('.upcoming-info');
      const endedInfo = document.querySelector('.ended-info');
      const cancelledInfo = document.querySelector('.cancelled-info');

      [bidSection, upcomingInfo, endedInfo, cancelledInfo].forEach(section => {
        if (section) section.style.display = 'none';
      });

      switch (this.auctionStatus) {
        case 'active':
          if (bidSection) bidSection.style.display = 'block';
          break;
        case 'upcoming':
          if (upcomingInfo) upcomingInfo.style.display = 'block';
          break;
        case 'ended':
          if (endedInfo) endedInfo.style.display = 'block';
          break;
        case 'cancelled':
          if (cancelledInfo) cancelledInfo.style.display = 'block';
          break;
      }
    }

    private getStatusColor(status: string): string {
      switch (status) {
        case 'upcoming': return 'text-blue-600 bg-blue-100';
        case 'active': return 'text-green-600 bg-green-100';
        case 'ended': return 'text-gray-600 bg-gray-100';
        case 'cancelled': return 'text-red-600 bg-red-100';
        default: return 'text-gray-600 bg-gray-100';
      }
    }

    private showNotification(message: string, type: 'success' | 'error' | 'info') {
      const notification = document.createElement('div');
      notification.className = `notification notification-${type}`;
      notification.textContent = message;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.remove();
      }, 3000);
    }
  }

  // Initialize auction when DOM is loaded
  let nftAuction: NFTAuction;
  
  document.addEventListener('DOMContentLoaded', () => {
    nftAuction = new NFTAuction(nftId, currentBid, minBid, timeRemaining, auctionStatus);
  });

  // Export for external use
  window.getNFTAuction = () => nftAuction;
</script>

<style>
  .nft-auction {
    @apply bg-white rounded-lg shadow-sm border border-gray-200 p-6 max-w-2xl mx-auto;
  }

  .auction-header {
    @apply flex justify-between items-start mb-6;
  }

  .nft-info {
    @apply flex items-center space-x-4;
  }

  .nft-image {
    @apply w-16 h-16 rounded-lg object-cover;
  }

  .nft-details {
    @apply space-y-1;
  }

  .nft-name {
    @apply font-semibold text-gray-900 text-lg;
  }

  .collection-name {
    @apply text-sm text-gray-600;
  }

  .auction-status {
    @apply px-3 py-1 rounded-full text-xs font-medium;
  }

  .auction-content {
    @apply space-y-4;
  }

  .bid-info {
    @apply grid grid-cols-2 gap-4;
  }

  .current-bid,
  .min-bid {
    @apply text-center p-4 bg-gray-50 rounded-lg;
  }

  .bid-label,
  .min-bid-label {
    @apply block text-sm text-gray-600 mb-1;
  }

  .bid-amount {
    @apply text-2xl font-bold text-gray-900;
  }

  .min-bid-amount {
    @apply text-lg font-semibold text-gray-700;
  }

  .time-remaining {
    @apply text-center p-4 bg-blue-50 rounded-lg;
  }

  .time-label {
    @apply block text-sm text-blue-600 mb-1;
  }

  .time-value {
    @apply text-xl font-bold text-blue-900;
  }

  .highest-bidder {
    @apply text-center p-3 bg-green-50 rounded-lg;
  }

  .bidder-label {
    @apply block text-sm text-green-600 mb-1;
  }

  .bidder-address {
    @apply font-mono text-green-900;
  }

  .bid-section {
    @apply space-y-4;
  }

  .bid-form {
    @apply space-y-3;
  }

  .bid-form-label {
    @apply block text-sm font-medium text-gray-700;
  }

  .bid-input-group {
    @apply flex space-x-2;
  }

  .bid-input {
    @apply flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500;
  }

  .bid-button {
    @apply px-6 py-2 bg-blue-600 text-white rounded-lg font-medium hover:bg-blue-700 transition-colors;
  }

  .bid-suggestions {
    @apply flex space-x-2;
  }

  .suggestion-btn {
    @apply px-3 py-1 text-sm bg-gray-100 text-gray-700 rounded hover:bg-gray-200 transition-colors;
  }

  .upcoming-info,
  .ended-info,
  .cancelled-info {
    @apply text-center p-4 rounded-lg;
  }

  .upcoming-info {
    @apply bg-blue-50;
  }

  .ended-info {
    @apply bg-gray-50;
  }

  .cancelled-info {
    @apply bg-red-50;
  }

  .upcoming-text,
  .ended-text,
  .cancelled-text {
    @apply text-lg font-medium mb-2;
  }

  .countdown {
    @apply text-2xl font-bold text-blue-900;
  }

  .winner-text {
    @apply text-gray-700;
  }

  .auction-actions {
    @apply flex space-x-3 pt-4 border-t border-gray-200;
  }

  .action-btn {
    @apply px-4 py-2 rounded-lg font-medium transition-colors;
  }

  .end-auction-btn {
    @apply bg-red-600 text-white hover:bg-red-700;
  }

  .cancel-auction-btn {
    @apply bg-yellow-600 text-white hover:bg-yellow-700;
  }

  .view-details-btn {
    @apply bg-gray-200 text-gray-700 hover:bg-gray-300;
  }

  .auction-history {
    @apply mt-6 pt-6 border-t border-gray-200;
  }

  .history-title {
    @apply text-lg font-semibold text-gray-900 mb-4;
  }

  .history-list {
    @apply space-y-2;
  }

  .history-item {
    @apply flex justify-between items-center p-3 bg-gray-50 rounded-lg;
  }

  .bidder {
    @apply font-mono text-sm text-gray-700;
  }

  .bid-amount {
    @apply font-semibold text-gray-900;
  }

  .bid-time {
    @apply text-sm text-gray-600;
  }

  .notification {
    @apply fixed top-4 right-4 px-4 py-2 rounded-lg text-white font-medium z-50;
  }

  .notification-success {
    @apply bg-green-600;
  }

  .notification-error {
    @apply bg-red-600;
  }

  .notification-info {
    @apply bg-blue-600;
  }
</style>

<!-- Global types for TypeScript -->
<script>
  declare global {
    interface Window {
      getNFTAuction: () => NFTAuction;
    }
  }
</script>
